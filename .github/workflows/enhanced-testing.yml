name: Enhanced Test Suite

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main]

env:
  NODE_ENV: test

jobs:
  enhanced-test-validation:
    name: Enhanced Test Suite Validation
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'
          cache-dependency-path: server/package-lock.json
      
      - name: Install dependencies
        run: |
          cd server
          npm ci --prefer-offline --no-audit
      
      - name: Build project
        run: |
          cd server
          npm run build
      
      - name: Run Basic Test Suite
        run: |
          cd server
          echo "üß™ Running basic test suite..."
          npm test
          echo "‚úÖ Basic test suite completed"
      
      - name: Enhanced MCP Server Integration Tests
        run: |
          cd server
          echo "üß™ Running enhanced MCP server integration tests..."
          
          node -e "
            async function enhancedIntegrationTests() {
              // Use dynamic imports for ES modules
              const { ApplicationOrchestrator } = await import('./dist/orchestration/index.js');
              const { MockLogger } = await import('./dist/utils/index.js');
              console.log('üîç Test 1: Full server initialization sequence');
              
              const logger = new MockLogger();
              const orchestrator = new ApplicationOrchestrator(logger);
              
              // Test configuration loading
              await orchestrator.loadConfiguration();
              if (!orchestrator.config) {
                throw new Error('Configuration not loaded');
              }
              console.log('‚úÖ Configuration loaded successfully');
              
              // Test prompts data loading
              await orchestrator.loadPromptsData();
              console.log(\`‚úÖ Prompts data loaded: \${orchestrator.promptsData ? orchestrator.promptsData.length : 0} prompts\`);
              
              // Test module initialization
              await orchestrator.initializeModules();
              if (!orchestrator.mcpToolsManager) {
                throw new Error('MCP tools manager not initialized');
              }
              console.log('‚úÖ Modules initialized successfully');
              
              console.log('üîç Test 2: Health monitoring functionality');
              
              // Test health monitoring
              const healthInfo = await orchestrator.collectHealthDiagnostics();
              if (!healthInfo || typeof healthInfo !== 'object') {
                throw new Error('Health diagnostics failed');
              }
              console.log(\`‚úÖ Health diagnostics collected: \${Object.keys(healthInfo).length} metrics\`);
              
              console.log('üîç Test 3: Graceful error handling');
              
              // Test error handling
              try {
                // Simulate an error condition
                await orchestrator.handleStartupFailure(new Error('Test error'));
                console.log('‚úÖ Error handling mechanism working');
              } catch (error) {
                // Expected to handle gracefully
                console.log('‚úÖ Error properly handled:', error.message.substring(0, 50));
              }
              
              console.log('üéâ Enhanced integration tests completed successfully');
            }
            
            enhancedIntegrationTests().catch(error => {
              console.error('‚ùå Enhanced integration tests failed:', error.message);
              console.error('Stack:', error.stack);
              process.exit(1);
            });
          "
      
      - name: CAGEERF Framework Comprehensive Tests
        run: |
          cd server
          echo "üß™ Running comprehensive CAGEERF framework tests..."
          
          node -e "
            async function comprehensiveFrameworkTests() {
              // Use dynamic imports for ES modules
              const { CAGEERFAnalyzer } = await import('./dist/utils/cageerf-analyzer.js');
              const { TemplateGenerator } = await import('./dist/utils/template-generator.js');
              const { TemplateRepositoryBuilder } = await import('./dist/utils/template-repository.js');
              const { SemanticAnalyzer } = await import('./dist/utils/semanticAnalyzer.js');
              const { MockLogger } = await import('./dist/utils/index.js');
              console.log('üîç Test 1: CAGEERF Analyzer edge cases');
              
              const analyzer = new CAGEERFAnalyzer();
              
              // Test with various input types
              const testCases = [
                '',  // Empty string
                'a',  // Single character
                'Simple prompt',  // Basic prompt
                'Context analysis goals execution evaluation refinement framework methodology systematic approach comprehensive validation',  // Keyword-rich
                'A'.repeat(10000),  // Very long input
                'üöÄ Analyze üìä the data with systematic approach and comprehensive evaluation! üéØ',  // With emojis
                'Create\\n\\tmulti-line\\nprompt\\twith\\ttabs'  // With special characters
              ];
              
              for (let i = 0; i < testCases.length; i++) {
                try {
                  const analysis = analyzer.analyzePrompt(testCases[i]);
                  
                  // Validate analysis structure
                  if (!analysis.compliance || !analysis.frameworkScore || analysis.overallCompliance === undefined) {
                    throw new Error(\`Invalid analysis structure for test case \${i + 1}\`);
                  }
                  
                  // Validate scores are in valid range
                  if (analysis.frameworkScore < 0 || analysis.frameworkScore > 1) {
                    throw new Error(\`Invalid framework score: \${analysis.frameworkScore}\`);
                  }
                  
                  if (analysis.overallCompliance < 0 || analysis.overallCompliance > 1) {
                    throw new Error(\`Invalid overall compliance: \${analysis.overallCompliance}\`);
                  }
                  
                  console.log(\`‚úÖ Test case \${i + 1} passed (score: \${analysis.frameworkScore.toFixed(3)})\`);
                } catch (error) {
                  throw new Error(\`CAGEERF analyzer test case \${i + 1} failed: \${error.message}\`);
                }
              }
              
              console.log('üîç Test 2: Template Generator comprehensive validation');
              
              const generator = new TemplateGenerator();
              
              // Test all complexity levels and styles
              const complexities = ['simple', 'intermediate', 'advanced', 'expert'];
              const styles = ['structured', 'conversational', 'academic', 'professional', 'creative'];
              
              for (const complexity of complexities) {
                for (const style of styles) {
                  try {
                    const template = generator.generateTemplate({
                      useCase: \`Test \${complexity} \${style}\`,
                      domain: 'Testing',
                      complexity: complexity,
                      frameworkEmphasis: {
                        context: true, analysis: true, goals: true,
                        execution: true, evaluation: true, refinement: true, framework: true
                      },
                      templateStyle: style
                    });
                    
                    // Validate template structure
                    if (!template.content || typeof template.content !== 'string') {
                      throw new Error('Invalid template content');
                    }
                    
                    if (!template.cageerfScore || template.cageerfScore < 0 || template.cageerfScore > 1) {
                      throw new Error(\`Invalid CAGEERF score: \${template.cageerfScore}\`);
                    }
                    
                    if (!template.qualityMetrics || typeof template.qualityMetrics !== 'object') {
                      throw new Error('Invalid quality metrics');
                    }
                    
                    // Validate minimum content length based on complexity
                    const minLengths = { simple: 100, intermediate: 300, advanced: 600, expert: 900 };
                    if (template.content.length < minLengths[complexity]) {
                      throw new Error(\`Template too short for \${complexity}: \${template.content.length} chars\`);
                    }
                    
                    console.log(\`‚úÖ Template \${complexity}/\${style} passed (score: \${template.cageerfScore.toFixed(3)}, length: \${template.content.length})\`);
                  } catch (error) {
                    throw new Error(\`Template generation failed for \${complexity}/\${style}: \${error.message}\`);
                  }
                }
              }
              
              console.log('üîç Test 3: Template Repository validation');
              
              const repository = TemplateRepositoryBuilder.buildRepository();
              
              // Validate repository structure
              if (!repository.templates || !Array.isArray(repository.templates)) {
                throw new Error('Invalid templates array');
              }
              
              if (!repository.categories || !Array.isArray(repository.categories)) {
                throw new Error('Invalid categories array');
              }
              
              // Validate each template
              for (let i = 0; i < repository.templates.length; i++) {
                const template = repository.templates[i];
                
                if (!template.name || !template.content || !template.category || !template.cageerfScore) {
                  throw new Error(\`Invalid template structure at index \${i}\`);
                }
                
                if (template.cageerfScore < 0.5) {
                  throw new Error(\`Low quality template: \${template.name} (score: \${template.cageerfScore})\`);
                }
              }
              
              console.log(\`‚úÖ Repository validation passed: \${repository.templates.length} templates, \${repository.categories.length} categories\`);
              
              console.log('üîç Test 4: Semantic Analyzer enhanced functionality');
              
              const semanticAnalyzer = new SemanticAnalyzer(new MockLogger());
              
              // Test various prompt types
              const promptTypes = [
                { content: 'List all available prompts', expectedType: 'template' },
                { content: 'Execute a comprehensive analysis workflow with multiple validation steps', expectedType: 'workflow' },
                { content: 'Create prompt1 | validate gates | execute prompt2 | analyze results', expectedType: 'chain' },
                { content: 'Analyze the context, set goals, execute systematic evaluation, and refine the framework', expectedType: 'workflow' }
              ];
              
              for (let i = 0; i < promptTypes.length; i++) {
                const prompt = {
                  id: \`test-prompt-\${i}\`,
                  name: \`Test Prompt \${i + 1}\`,
                  content: promptTypes[i].content,
                  description: 'Test prompt for semantic analysis'
                };
                
                try {
                  const classification = semanticAnalyzer.classifyPrompt(prompt);
                  
                  // Validate classification structure
                  if (!classification.executionType || !classification.confidence || !classification.reasoning) {
                    throw new Error(\`Invalid classification structure for prompt \${i + 1}\`);
                  }
                  
                  // Validate CAGEERF integration
                  if (!classification.cageerfAnalysis || classification.frameworkCompliance === undefined) {
                    throw new Error(\`Missing CAGEERF integration for prompt \${i + 1}\`);
                  }
                  
                  console.log(\`‚úÖ Semantic analysis \${i + 1} passed: \${classification.executionType} (confidence: \${classification.confidence.toFixed(3)})\`);
                } catch (error) {
                  throw new Error(\`Semantic analysis failed for prompt \${i + 1}: \${error.message}\`);
                }
              }
              
              console.log('üéâ Comprehensive CAGEERF framework tests completed successfully');
            }
            
            comprehensiveFrameworkTests().catch(error => {
              console.error('‚ùå CAGEERF framework tests failed:', error.message);
              process.exit(1);
            });
          "
      
      - name: MCP Tools Comprehensive Tests
        run: |
          cd server
          echo "üß™ Running comprehensive MCP tools tests..."
          
          node -e "
            async function comprehensiveMcpToolsTests() {
              // Use dynamic imports for ES modules
              const { McpToolsManager } = await import('./dist/mcp-tools/index.js');
              const { TemplateGenerationTools } = await import('./dist/mcp-tools/template-generation-tools.js');
              const { MockLogger } = await import('./dist/utils/index.js');
              console.log('üîç Test 1: MCP Tools Manager complete functionality');
              
              const toolCalls = [];
              const mockMcpServer = {
                tool: function(name, description, schema) {
                  toolCalls.push({ name, description, schema });
                  
                  // Return a mock tool handler
                  return {
                    name,
                    handler: async (args) => {
                      return {
                        content: [{ type: 'text', text: \`Mock response for \${name} with args: \${JSON.stringify(args)}\` }]
                      };
                    }
                  };
                }
              };
              
              const logger = new MockLogger();
              const toolsManager = new McpToolsManager(logger, mockMcpServer, {});
              
              // Set test data
              const testPromptsData = [
                {
                  id: 'test-1',
                  name: 'Test Prompt 1',
                  content: 'Test content with context and analysis components',
                  description: 'Test prompt description'
                }
              ];
              
              const testConvertedPrompts = [
                {
                  id: 'test-1',
                  name: 'Test Prompt 1',
                  content: 'Test content',
                  description: 'Test description',
                  category: 'test',
                  executionMode: 'template'
                }
              ];
              
              const testCategories = [
                { name: 'test', description: 'Test category' }
              ];
              
              toolsManager.updateData(testPromptsData, testConvertedPrompts, testCategories);
              
              // Test tool registration
              toolsManager.registerAllTools();
              
              if (toolCalls.length === 0) {
                throw new Error('No tools were registered');
              }
              
              console.log(\`‚úÖ MCP Tools Manager registered \${toolCalls.length} tools\`);
              
              // Validate essential tools are present
              const registeredNames = toolCalls.map(t => t.name);
              const essentialTools = ['update_prompt', 'list_prompts', 'execute_prompt'];
              
              for (const tool of essentialTools) {
                if (!registeredNames.includes(tool)) {
                  console.log(\`‚ö†Ô∏è  Essential tool missing: \${tool}\`);
                } else {
                  console.log(\`‚úÖ Essential tool found: \${tool}\`);
                }
              }
              
              console.log('üîç Test 2: Template Generation Tools validation');
              
              const templateTools = new TemplateGenerationTools(logger, mockMcpServer);
              const beforeCount = toolCalls.length;
              
              templateTools.registerAllTools();
              const templateToolsCount = toolCalls.length - beforeCount;
              
              if (templateToolsCount === 0) {
                throw new Error('No template generation tools were registered');
              }
              
              console.log(\`‚úÖ Template Generation Tools registered \${templateToolsCount} additional tools\`);
              
              // Validate template-specific tools
              const templateToolNames = ['generate_template', 'enhance_template', 'get_template_categories', 'get_template_patterns'];
              for (const toolName of templateToolNames) {
                if (!registeredNames.includes(toolName) && !toolCalls.slice(beforeCount).some(t => t.name === toolName)) {
                  console.log(\`‚ö†Ô∏è  Template tool missing: \${toolName}\`);
                } else {
                  console.log(\`‚úÖ Template tool found: \${toolName}\`);
                }
              }
              
              console.log('üîç Test 3: Tool schema validation');
              
              // Validate all tool schemas
              for (const tool of toolCalls) {
                if (!tool.schema || typeof tool.schema !== 'object') {
                  throw new Error(\`Invalid schema for tool: \${tool.name}\`);
                }
                
                // Check for common schema properties
                if (Object.keys(tool.schema).length === 0) {
                  console.log(\`‚ö†Ô∏è  Empty schema for tool: \${tool.name}\`);
                } else {
                  console.log(\`‚úÖ Schema validated for tool: \${tool.name}\`);
                }
              }
              
              console.log('üéâ Comprehensive MCP tools tests completed successfully');
            }
            
            comprehensiveMcpToolsTests().catch(error => {
              console.error('‚ùå MCP tools tests failed:', error.message);
              process.exit(1);
            });
          "
      
      - name: Error Handling and Edge Cases Tests
        run: |
          cd server
          echo "üß™ Running error handling and edge case tests..."
          
          node -e "
            async function errorHandlingTests() {
              // Use dynamic imports for ES modules
              const { ApplicationOrchestrator } = await import('./dist/orchestration/index.js');
              const { CAGEERFAnalyzer } = await import('./dist/utils/cageerf-analyzer.js');
              const { TemplateGenerator } = await import('./dist/utils/template-generator.js');
              const { MockLogger } = await import('./dist/utils/index.js');
              console.log('üîç Test 1: Graceful error handling');
              
              const logger = new MockLogger();
              
              // Test 1: Invalid configuration handling
              try {
                const orchestrator = new ApplicationOrchestrator(logger);
                // This should not throw immediately
                console.log('‚úÖ Orchestrator handles invalid initial state gracefully');
              } catch (error) {
                throw new Error(\`Orchestrator failed to handle initialization: \${error.message}\`);
              }
              
              // Test 2: CAGEERF analyzer with problematic inputs
              const analyzer = new CAGEERFAnalyzer();
              
              const problematicInputs = [
                null,
                undefined,
                {},
                [],
                12345,
                { invalid: 'object' }
              ];
              
              for (let i = 0; i < problematicInputs.length; i++) {
                try {
                  const result = analyzer.analyzePrompt(problematicInputs[i]);
                  
                  // Should return valid analysis structure even for invalid input
                  if (!result.compliance || result.frameworkScore === undefined) {
                    throw new Error(\`Invalid result structure for problematic input \${i + 1}\`);
                  }
                  
                  console.log(\`‚úÖ CAGEERF analyzer handled problematic input \${i + 1} gracefully\`);
                } catch (error) {
                  throw new Error(\`CAGEERF analyzer failed on input \${i + 1}: \${error.message}\`);
                }
              }
              
              // Test 3: Template generator with invalid requests
              const generator = new TemplateGenerator();
              
              const invalidRequests = [
                {},  // Empty request
                { useCase: '' },  // Empty use case
                { useCase: 'Test', complexity: 'invalid' },  // Invalid complexity
                { useCase: 'Test', complexity: 'simple', frameworkEmphasis: null }  // Invalid emphasis
              ];
              
              for (let i = 0; i < invalidRequests.length; i++) {
                try {
                  const result = generator.generateTemplate(invalidRequests[i]);
                  
                  // Should return some form of template even for invalid requests
                  if (!result.content || typeof result.content !== 'string') {
                    throw new Error(\`Invalid template result for request \${i + 1}\`);
                  }
                  
                  console.log(\`‚úÖ Template generator handled invalid request \${i + 1} gracefully\`);
                } catch (error) {
                  throw new Error(\`Template generator failed on request \${i + 1}: \${error.message}\`);
                }
              }
              
              console.log('üîç Test 2: Memory leak prevention');
              
              // Test for potential memory leaks with repeated operations
              const initialMemory = process.memoryUsage().heapUsed;
              
              for (let i = 0; i < 100; i++) {
                analyzer.analyzePrompt('Memory leak test prompt with comprehensive analysis components');
                generator.generateTemplate({
                  useCase: 'Memory Test',
                  domain: 'Testing',
                  complexity: 'simple',
                  frameworkEmphasis: { context: true, analysis: true, goals: true, execution: true, evaluation: true, refinement: true, framework: true },
                  templateStyle: 'structured'
                });
              }
              
              global.gc && global.gc();
              const finalMemory = process.memoryUsage().heapUsed;
              const memoryIncrease = finalMemory - initialMemory;
              
              // Check if memory increase is reasonable (less than 50MB for 100 operations)
              if (memoryIncrease > 50 * 1024 * 1024) {
                console.log(\`‚ö†Ô∏è  Potential memory leak detected: \${Math.round(memoryIncrease / 1024 / 1024)}MB increase\`);
              } else {
                console.log(\`‚úÖ Memory usage acceptable: \${Math.round(memoryIncrease / 1024 / 1024)}MB increase for 100 operations\`);
              }
              
              console.log('üîç Test 3: Concurrent operation handling');
              
              // Test concurrent operations
              const concurrentPromises = [];
              for (let i = 0; i < 10; i++) {
                concurrentPromises.push(
                  Promise.resolve().then(() => {
                    const analysis = analyzer.analyzePrompt(\`Concurrent test \${i} with analysis components\`);
                    const template = generator.generateTemplate({
                      useCase: \`Concurrent Test \${i}\`,
                      domain: 'Testing',
                      complexity: 'simple',
                      frameworkEmphasis: { context: true, analysis: true, goals: true, execution: true, evaluation: true, refinement: true, framework: true },
                      templateStyle: 'structured'
                    });
                    return { analysis, template };
                  })
                );
              }
              
              return Promise.all(concurrentPromises).then(results => {
                if (results.length !== 10) {
                  throw new Error(\`Expected 10 concurrent results, got \${results.length}\`);
                }
                
                for (let i = 0; i < results.length; i++) {
                  if (!results[i].analysis || !results[i].template) {
                    throw new Error(\`Invalid concurrent result \${i + 1}\`);
                  }
                }
                
                console.log('‚úÖ Concurrent operations handled successfully');
                console.log('üéâ Error handling and edge case tests completed successfully');
              });
            }
            
            errorHandlingTests().catch(error => {
              console.error('‚ùå Error handling tests failed:', error.message);
              process.exit(1);
            });
          " --expose-gc
      
      - name: Integration Smoke Tests
        run: |
          cd server
          echo "üß™ Running integration smoke tests..."
          
          node -e "
            async function smokeTests() {
              // Use dynamic imports for ES modules
              const { ApplicationOrchestrator } = await import('./dist/orchestration/index.js');
              const { MockLogger } = await import('./dist/utils/index.js');
              console.log('üîç Smoke Test: Full system integration');
              
              const logger = new MockLogger();
              const orchestrator = new ApplicationOrchestrator(logger);
              
              // Quick initialization test
              const startTime = Date.now();
              
              await orchestrator.loadConfiguration();
              await orchestrator.loadPromptsData();
              await orchestrator.initializeModules();
              
              const initTime = Date.now() - startTime;
              
              // Health check
              const health = await orchestrator.collectHealthDiagnostics();
              
              console.log('üìä Smoke Test Results:');
              console.log(\`   Initialization time: \${initTime}ms\`);
              console.log(\`   Health metrics: \${Object.keys(health).length}\`);
              console.log(\`   Prompts loaded: \${orchestrator.promptsData ? orchestrator.promptsData.length : 0}\`);
              console.log(\`   Categories: \${orchestrator.categories ? orchestrator.categories.length : 0}\`);
              
              // Quick performance check
              if (initTime > 5000) {
                console.log(\`‚ö†Ô∏è  Initialization took \${initTime}ms (threshold: 5000ms)\`);
              } else {
                console.log('‚úÖ Initialization performance acceptable');
              }
              
              // Memory check
              const memory = process.memoryUsage();
              const heapMB = Math.round(memory.heapUsed / 1024 / 1024);
              
              if (heapMB > 200) {
                console.log(\`‚ö†Ô∏è  High memory usage: \${heapMB}MB (threshold: 200MB)\`);
              } else {
                console.log(\`‚úÖ Memory usage acceptable: \${heapMB}MB\`);
              }
              
              console.log('üéâ Integration smoke tests completed successfully');
            }
            
            smokeTests().catch(error => {
              console.error('‚ùå Smoke tests failed:', error.message);
              process.exit(1);
            });
          "
      
      - name: Test Results Summary
        run: |
          echo "‚úÖ Enhanced Test Suite Summary"
          echo "==============================="
          echo "‚úÖ Basic test suite: PASSED"
          echo "‚úÖ Enhanced MCP integration tests: PASSED"
          echo "‚úÖ CAGEERF framework comprehensive tests: PASSED"
          echo "‚úÖ MCP tools comprehensive tests: PASSED"
          echo "‚úÖ Error handling and edge cases: PASSED"
          echo "‚úÖ Integration smoke tests: PASSED"
          echo ""
          echo "üéâ All enhanced tests completed successfully!"
          echo "üìä Test coverage includes:"
          echo "   - Core functionality validation"
          echo "   - CAGEERF framework integration"
          echo "   - MCP protocol compliance"
          echo "   - Error handling robustness"
          echo "   - Performance characteristics"
          echo "   - Memory usage patterns"
          echo "   - Concurrent operation safety"