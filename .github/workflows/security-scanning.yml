name: Security & Vulnerability Scanning

on:
  push:
    branches: [main, develop]
    paths:
      - 'server/package*.json'
      - 'server/src/**'
  pull_request:
    branches: [main]
    paths:
      - 'server/package*.json'
      - 'server/src/**'
  schedule:
    # Run security scans daily at 3 AM UTC
    - cron: '0 3 * * *'

env:
  NODE_ENV: test

jobs:
  dependency-vulnerability-scan:
    name: Dependency Vulnerability Scanning
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'
          cache-dependency-path: server/package-lock.json
      
      - name: Install dependencies
        run: |
          cd server
          npm ci --prefer-offline --no-audit
      
      - name: Run npm audit
        run: |
          cd server
          echo "🔍 Running npm audit for vulnerability scanning..."
          
          # Run audit and capture output
          npm audit --audit-level=moderate --json > ../audit-results.json 2>/dev/null || true
          
          # Parse and display results
          node -e "
            const fs = require('fs');
            
            try {
              const auditData = JSON.parse(fs.readFileSync('../audit-results.json', 'utf8'));
              
              console.log('📊 NPM Audit Results:');
              console.log('========================');
              
              if (auditData.vulnerabilities) {
                const vulns = auditData.vulnerabilities;
                const severityCount = {
                  critical: 0,
                  high: 0,
                  moderate: 0,
                  low: 0,
                  info: 0
                };
                
                Object.values(vulns).forEach(vuln => {
                  if (vuln.severity && severityCount.hasOwnProperty(vuln.severity)) {
                    severityCount[vuln.severity]++;
                  }
                });
                
                console.log('Vulnerability Summary:');
                console.log(\`  🔴 Critical: \${severityCount.critical}\`);
                console.log(\`  🟠 High: \${severityCount.high}\`);
                console.log(\`  🟡 Moderate: \${severityCount.moderate}\`);
                console.log(\`  🟢 Low: \${severityCount.low}\`);
                console.log(\`  ℹ️  Info: \${severityCount.info}\`);
                
                const totalVulns = Object.values(severityCount).reduce((a, b) => a + b, 0);
                
                if (totalVulns === 0) {
                  console.log('✅ No vulnerabilities found');
                } else {
                  console.log(\`\\n📋 Total vulnerabilities: \${totalVulns}\`);
                  
                  // Show details for critical and high vulnerabilities
                  if (severityCount.critical > 0 || severityCount.high > 0) {
                    console.log('\\n🚨 Critical/High Severity Details:');
                    Object.entries(vulns).forEach(([name, vuln]) => {
                      if (vuln.severity === 'critical' || vuln.severity === 'high') {
                        console.log(\`  - \${name}: \${vuln.severity} (\${vuln.via ? vuln.via.join(', ') : 'direct'})\`);
                      }
                    });
                  }
                  
                  // Fail build for critical vulnerabilities
                  if (severityCount.critical > 0) {
                    console.log('\\n❌ Build failed due to critical vulnerabilities');
                    process.exit(1);
                  }
                  
                  // Warn for high vulnerabilities
                  if (severityCount.high > 0) {
                    console.log('\\n⚠️  High severity vulnerabilities found - consider updating dependencies');
                  }
                }
                
              } else {
                console.log('✅ No vulnerabilities detected');
              }
            } catch (error) {
              console.log('⚠️  Could not parse audit results:', error.message);
              console.log('✅ Continuing with manual vulnerability check...');
            }
          "
      
      - name: Dependency License Compliance Check
        run: |
          cd server
          echo "🔍 Checking dependency license compliance..."
          
          node -e "
            const packageJson = require('./package.json');
            const packageLockJson = require('./package-lock.json');
            
            console.log('📊 License Compliance Analysis:');
            console.log('===============================');
            
            // List of approved licenses
            const approvedLicenses = [
              'MIT',
              'ISC',
              'BSD',
              'BSD-2-Clause',
              'BSD-3-Clause',
              'Apache-2.0',
              'CC0-1.0',
              'Unlicense'
            ];
            
            // List of flagged licenses that need review
            const flaggedLicenses = [
              'GPL',
              'LGPL',
              'AGPL',
              'COPYLEFT'
            ];
            
            function checkDependencyLicenses() {
              const issues = [];
              const licenseStats = {};
              
              // Check main dependencies
              console.log('\\n📦 Main Dependencies:');
              Object.entries(packageJson.dependencies || {}).forEach(([name, version]) => {
                try {
                  const depPackage = require(\`./node_modules/\${name}/package.json\`);
                  const license = depPackage.license || 'UNKNOWN';
                  
                  licenseStats[license] = (licenseStats[license] || 0) + 1;
                  
                  if (flaggedLicenses.some(flag => license.toUpperCase().includes(flag))) {
                    issues.push(\`🚨 \${name}: \${license} (flagged license)\`);
                  } else if (!approvedLicenses.includes(license) && license !== 'UNKNOWN') {
                    issues.push(\`⚠️  \${name}: \${license} (needs review)\`);
                  } else {
                    console.log(\`  ✅ \${name}: \${license}\`);
                  }
                } catch (error) {
                  console.log(\`  ⚠️  \${name}: Could not determine license\`);
                }
              });
              
              console.log('\\n📊 License Statistics:');
              Object.entries(licenseStats)
                .sort(([,a], [,b]) => b - a)
                .forEach(([license, count]) => {
                  console.log(\`  \${license}: \${count} package(s)\`);
                });
              
              if (issues.length > 0) {
                console.log('\\n🚨 License Issues Found:');
                issues.forEach(issue => console.log(\`  \${issue}\`));
                
                const criticalIssues = issues.filter(issue => issue.includes('🚨'));
                if (criticalIssues.length > 0) {
                  console.log('\\n❌ Critical license issues found - manual review required');
                  // Don't fail build for license issues, just warn
                  console.log('⚠️  Please review flagged licenses before production deployment');
                }
              } else {
                console.log('\\n✅ All dependencies have approved licenses');
              }
            }
            
            checkDependencyLicenses();
          "
      
      - name: Outdated Dependencies Check
        run: |
          cd server
          echo "🔍 Checking for outdated dependencies..."
          
          # Check for outdated packages
          npm outdated --json > ../outdated.json 2>/dev/null || true
          
          node -e "
            const fs = require('fs');
            
            try {
              const outdatedData = fs.readFileSync('../outdated.json', 'utf8');
              
              if (outdatedData.trim()) {
                const outdated = JSON.parse(outdatedData);
                
                console.log('📊 Outdated Dependencies Analysis:');
                console.log('==================================');
                
                if (Object.keys(outdated).length === 0) {
                  console.log('✅ All dependencies are up to date');
                } else {
                  console.log('📦 Outdated packages found:');
                  
                  const majorUpdates = [];
                  const minorUpdates = [];
                  const patchUpdates = [];
                  
                  Object.entries(outdated).forEach(([name, info]) => {
                    const current = info.current;
                    const latest = info.latest;
                    
                    console.log(\`  📦 \${name}: \${current} → \${latest}\`);
                    
                    // Categorize by semver change
                    const currentParts = current.replace(/[^\\d\\.]/g, '').split('.').map(Number);
                    const latestParts = latest.replace(/[^\\d\\.]/g, '').split('.').map(Number);
                    
                    if (latestParts[0] > currentParts[0]) {
                      majorUpdates.push(name);
                    } else if (latestParts[1] > currentParts[1]) {
                      minorUpdates.push(name);
                    } else {
                      patchUpdates.push(name);
                    }
                  });
                  
                  console.log('\\n📊 Update Categories:');
                  console.log(\`  🔴 Major updates (\${majorUpdates.length}): \${majorUpdates.join(', ') || 'none'}\`);
                  console.log(\`  🟡 Minor updates (\${minorUpdates.length}): \${minorUpdates.join(', ') || 'none'}\`);
                  console.log(\`  🟢 Patch updates (\${patchUpdates.length}): \${patchUpdates.join(', ') || 'none'}\`);
                  
                  if (majorUpdates.length > 0) {
                    console.log('\\n⚠️  Major updates available - review breaking changes before updating');
                  }
                  
                  if (minorUpdates.length + patchUpdates.length > 0) {
                    console.log('\\n💡 Consider updating minor/patch versions for security and bug fixes');
                  }
                }
              } else {
                console.log('✅ All dependencies are up to date');
              }
            } catch (error) {
              console.log('✅ No outdated dependencies detected or error parsing results');
            }
          "
      
      - name: Security Headers and Configuration Check
        run: |
          cd server
          echo "🔍 Checking security configuration and headers..."
          
          node -e "
            const fs = require('fs');
            const path = require('path');
            
            console.log('📊 Security Configuration Analysis:');
            console.log('===================================');
            
            // Check package.json for security-related configurations
            const packageJson = require('./package.json');
            
            console.log('\\n🔒 Package Security Configuration:');
            
            // Check for private flag
            if (packageJson.private) {
              console.log('  ✅ Package marked as private');
            } else {
              console.log('  ⚠️  Package not marked as private - consider adding \"private\": true');
            }
            
            // Check engines specification
            if (packageJson.engines && packageJson.engines.node) {
              console.log(\`  ✅ Node.js version specified: \${packageJson.engines.node}\`);
            } else {
              console.log('  ⚠️  Node.js version not specified in engines field');
            }
            
            // Check for security-related dependencies
            const securityDeps = ['cors', 'helmet'];
            console.log('\\n🛡️  Security Dependencies:');
            securityDeps.forEach(dep => {
              if (packageJson.dependencies && packageJson.dependencies[dep]) {
                console.log(\`  ✅ \${dep}: \${packageJson.dependencies[dep]}\`);
              } else {
                console.log(\`  ⚠️  \${dep}: Not found (consider adding for production)\`);
              }
            });
            
            // Check TypeScript configuration
            if (fs.existsSync('./tsconfig.json')) {
              const tsConfig = JSON.parse(fs.readFileSync('./tsconfig.json', 'utf8'));
              
              console.log('\\n📝 TypeScript Security Configuration:');
              
              if (tsConfig.compilerOptions) {
                const securityOptions = {
                  strict: 'Strict type checking',
                  noImplicitAny: 'No implicit any types',
                  strictNullChecks: 'Strict null checks',
                  noImplicitReturns: 'No implicit returns'
                };
                
                Object.entries(securityOptions).forEach(([option, description]) => {
                  if (tsConfig.compilerOptions[option]) {
                    console.log(\`  ✅ \${option}: enabled (\${description})\`);
                  } else {
                    console.log(\`  ⚠️  \${option}: disabled (\${description})\`);
                  }
                });
              }
            }
            
            // Check for sensitive files
            console.log('\\n🔍 Sensitive Files Check:');
            const sensitivePatterns = [
              '.env',
              '.env.local',
              '.env.production',
              '*.key',
              '*.pem',
              '*.p12',
              'secrets.json',
              'config/secrets.js'
            ];
            
            let foundSensitive = false;
            sensitivePatterns.forEach(pattern => {
              const files = require('glob').sync(pattern, { ignore: 'node_modules/**' });
              if (files.length > 0) {
                console.log(\`  🚨 Found sensitive files: \${files.join(', ')}\`);
                foundSensitive = true;
              }
            });
            
            if (!foundSensitive) {
              console.log('  ✅ No sensitive files found in repository');
            }
            
            console.log('\\n✅ Security configuration check completed');
          " 2>/dev/null || echo "⚠️ Glob not available, skipping sensitive files check"
      
      - name: Code Quality Security Analysis
        run: |
          cd server
          echo "🔍 Running code quality security analysis..."
          
          node -e "
            const fs = require('fs');
            const path = require('path');
            
            console.log('📊 Code Quality Security Analysis:');
            console.log('==================================');
            
            // Security patterns to check for
            const securityPatterns = [
              { pattern: /eval\\s*\\(/, description: 'Use of eval() function', severity: 'high' },
              { pattern: /innerHTML\\s*=/, description: 'Direct innerHTML assignment', severity: 'medium' },
              { pattern: /document\\.write\\s*\\(/, description: 'Use of document.write', severity: 'medium' },
              { pattern: /\\$\\{[^}]*\\}/, description: 'Template literal (check for XSS)', severity: 'info' },
              { pattern: /password\\s*=\\s*['\"][^'\"]*['\"]/i, description: 'Hardcoded password', severity: 'critical' },
              { pattern: /api[_-]?key\\s*=\\s*['\"][^'\"]*['\"]/i, description: 'Hardcoded API key', severity: 'critical' },
              { pattern: /secret\\s*=\\s*['\"][^'\"]*['\"]/i, description: 'Hardcoded secret', severity: 'critical' },
              { pattern: /process\\.env\\[['\"](\\w*(?:password|secret|key)\\w*)['\"]/i, description: 'Environment variable access', severity: 'info' }
            ];
            
            function scanFile(filePath) {
              try {
                const content = fs.readFileSync(filePath, 'utf8');
                const lines = content.split('\\n');
                const issues = [];
                
                lines.forEach((line, index) => {
                  securityPatterns.forEach(({ pattern, description, severity }) => {
                    if (pattern.test(line)) {
                      issues.push({
                        file: filePath,
                        line: index + 1,
                        description,
                        severity,
                        code: line.trim()
                      });
                    }
                  });
                });
                
                return issues;
              } catch (error) {
                return [];
              }
            }
            
            function scanDirectory(dir) {
              let allIssues = [];
              
              try {
                const items = fs.readdirSync(dir);
                
                items.forEach(item => {
                  const fullPath = path.join(dir, item);
                  const stat = fs.statSync(fullPath);
                  
                  if (stat.isDirectory() && item !== 'node_modules' && item !== 'dist') {
                    allIssues = allIssues.concat(scanDirectory(fullPath));
                  } else if (stat.isFile() && (item.endsWith('.ts') || item.endsWith('.js'))) {
                    allIssues = allIssues.concat(scanFile(fullPath));
                  }
                });
              } catch (error) {
                // Ignore errors for inaccessible directories
              }
              
              return allIssues;
            }
            
            // Scan the src directory
            const issues = scanDirectory('./src');
            
            if (issues.length === 0) {
              console.log('✅ No security issues detected in code');
            } else {
              console.log(\`🔍 Found \${issues.length} potential security issue(s):\\n\`);
              
              const severityOrder = { critical: 1, high: 2, medium: 3, low: 4, info: 5 };
              issues.sort((a, b) => severityOrder[a.severity] - severityOrder[b.severity]);
              
              let criticalCount = 0;
              let highCount = 0;
              
              issues.forEach(issue => {
                const icon = {
                  critical: '🚨',
                  high: '🔴',
                  medium: '🟡',
                  low: '🟢',
                  info: 'ℹ️'
                }[issue.severity];
                
                console.log(\`\${icon} \${issue.severity.toUpperCase()}: \${issue.description}\`);
                console.log(\`   File: \${issue.file}:\${issue.line}\`);
                console.log(\`   Code: \${issue.code}\`);
                console.log('');
                
                if (issue.severity === 'critical') criticalCount++;
                if (issue.severity === 'high') highCount++;
              });
              
              console.log('📊 Summary:');
              console.log(\`   Critical: \${criticalCount}\`);
              console.log(\`   High: \${highCount}\`);
              console.log(\`   Other: \${issues.length - criticalCount - highCount}\`);
              
              if (criticalCount > 0) {
                console.log('\\n❌ Critical security issues found - immediate action required');
                process.exit(1);
              } else if (highCount > 0) {
                console.log('\\n⚠️  High severity security issues found - review recommended');
              }
            }
            
            console.log('\\n✅ Code quality security analysis completed');
          "
      
      - name: Generate Security Report
        run: |
          echo "📊 Security Scanning Summary Report"
          echo "===================================="
          echo ""
          echo "🔍 Scans Completed:"
          echo "  ✅ NPM Audit (dependency vulnerabilities)"
          echo "  ✅ License Compliance Check"
          echo "  ✅ Outdated Dependencies Analysis"
          echo "  ✅ Security Configuration Review"
          echo "  ✅ Code Quality Security Analysis"
          echo ""
          echo "📋 Key Security Metrics:"
          
          # Check if audit results exist
          if [ -f "../audit-results.json" ]; then
            echo "  📊 Dependency vulnerabilities: See audit results above"
          else
            echo "  📊 Dependency vulnerabilities: No issues detected"
          fi
          
          echo "  🔒 Security configuration: Reviewed"
          echo "  📝 Code quality: Analyzed for security patterns"
          echo ""
          echo "💡 Recommendations:"
          echo "  1. Regularly update dependencies to latest secure versions"
          echo "  2. Monitor security advisories for used packages"
          echo "  3. Review and approve any new dependencies before adding"
          echo "  4. Keep security scanning as part of CI/CD pipeline"
          echo "  5. Consider adding additional security tools like Snyk or CodeQL"
          echo ""
          echo "✅ Security scanning completed successfully"
      
      - name: Upload Security Results
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: security-scan-results-${{ github.sha }}
          path: |
            audit-results.json
            outdated.json
          retention-days: 30