name: Deployment Preparation

on:
  push:
    branches: [main]
    tags: ['v*']
  pull_request:
    branches: [main]
  workflow_dispatch:
    inputs:
      release_type:
        description: 'Release type (patch, minor, major)'
        required: false
        default: 'patch'
        type: choice
        options:
          - patch
          - minor
          - major

env:
  NODE_ENV: production

jobs:
  artifact-generation:
    name: Generate Deployment Artifacts
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Fetch full history for changelog generation
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'
          cache-dependency-path: server/package-lock.json
      
      - name: Install dependencies
        run: |
          cd server
          npm ci --prefer-offline --no-audit
      
      - name: Generate production build
        run: |
          cd server
          echo "🔨 Generating production build..."
          
          # Set production environment
          export NODE_ENV=production
          
          # Clean previous build
          rm -rf dist
          
          # Generate build
          npm run build
          
          # Validate build
          if [ ! -d "dist" ] || [ ! -f "dist/index.js" ]; then
            echo "❌ Production build failed"
            exit 1
          fi
          
          echo "✅ Production build generated successfully"
      
      - name: Generate source maps
        run: |
          cd server
          echo "🗺️  Generating source maps for debugging..."
          
          # Check if TypeScript compiler generates source maps
          if [ -f "tsconfig.json" ]; then
            node -e "
              async function checkSourceMaps() {
                // Use dynamic imports for ES modules
                const fs = await import('fs');
                
                const tsConfig = JSON.parse(fs.readFileSync('tsconfig.json', 'utf8'));
                
                if (tsConfig.compilerOptions && tsConfig.compilerOptions.sourceMap) {
                  console.log('✅ Source maps are enabled in tsconfig.json');
                } else {
                  console.log('⚠️  Source maps not enabled in tsconfig.json');
                  console.log('Adding source map generation...');
                  
                  // Enable source maps
                  tsConfig.compilerOptions = tsConfig.compilerOptions || {};
                  tsConfig.compilerOptions.sourceMap = true;
                  
                  fs.writeFileSync('tsconfig.json', JSON.stringify(tsConfig, null, 2));
                  console.log('✅ Source maps enabled');
                }
              }
              
              checkSourceMaps().catch(error => {
                console.error('❌ Source map check failed:', error.message);
                process.exit(1);
              });
            "
          fi
          
          # Rebuild with source maps
          npm run build
          
          # Check for source map files
          map_files=$(find dist -name "*.map" | wc -l)
          echo "📊 Source map files generated: $map_files"
          
          echo "✅ Source maps generation completed"
      
      - name: Create deployment bundle
        run: |
          cd server
          echo "📦 Creating deployment bundle..."
          
          # Create deployment directory
          mkdir -p ../deployment-bundle
          
          # Copy essential files
          cp -r dist ../deployment-bundle/
          cp package.json ../deployment-bundle/
          cp package-lock.json ../deployment-bundle/
          
          # Copy configuration files
          cp config.json ../deployment-bundle/ 2>/dev/null || echo "⚠️  config.json not found"
          cp promptsConfig.json ../deployment-bundle/ 2>/dev/null || echo "⚠️  promptsConfig.json not found"
          
          # Copy prompts directory
          cp -r prompts ../deployment-bundle/ 2>/dev/null || echo "⚠️  prompts directory not found"
          
          # Create deployment package.json (production only)
          node -e "
            async function createProductionPackageJson() {
              // Use dynamic imports for ES modules
              const fs = await import('fs');
              
              const packageJson = JSON.parse(fs.readFileSync('../deployment-bundle/package.json', 'utf8'));
              
              // Create production package.json
              const prodPackageJson = {
                name: packageJson.name,
                version: packageJson.version,
                description: packageJson.description,
                main: packageJson.main,
                scripts: {
                  start: packageJson.scripts.start || 'node dist/index.js',
                  'start:production': packageJson.scripts['start:production'] || 'node dist/index.js'
                },
                dependencies: packageJson.dependencies || {},
                engines: packageJson.engines || {},
                author: packageJson.author,
                license: packageJson.license,
                repository: packageJson.repository,
                keywords: packageJson.keywords || []
              };
              
              fs.writeFileSync('../deployment-bundle/package.json', JSON.stringify(prodPackageJson, null, 2));
              console.log('✅ Production package.json created');
            }
            
            createProductionPackageJson().catch(error => {
              console.error('❌ Production package.json creation failed:', error.message);
              process.exit(1);
            });
          "
          
          # Create deployment info
          echo "# Deployment Bundle" > ../deployment-bundle/README.md
          echo "Generated: $(date)" >> ../deployment-bundle/README.md
          echo "Commit: $(git rev-parse HEAD)" >> ../deployment-bundle/README.md
          echo "Branch: $(git branch --show-current)" >> ../deployment-bundle/README.md
          
          # Calculate bundle size
          bundle_size=$(du -sh ../deployment-bundle | cut -f1)
          echo "📊 Deployment bundle size: $bundle_size"
          
          echo "✅ Deployment bundle created successfully"
      
      - name: Validate deployment bundle
        run: |
          cd deployment-bundle
          echo "🔍 Validating deployment bundle..."
          
          # Check required files
          required_files=(
            "package.json"
            "dist/index.js"
            "dist/orchestration/index.js"
            "dist/mcp-tools/index.js"
          )
          
          for file in "${required_files[@]}"; do
            if [ ! -f "$file" ]; then
              echo "❌ Required file missing: $file"
              exit 1
            fi
          done
          
          # Test bundle installation
          echo "🔧 Testing bundle installation..."
          npm install --only=production
          
          # Test bundle execution
          echo "🚀 Testing bundle execution..."
          timeout 10s npm start || {
            echo "⚠️  Bundle execution test timeout - this may be expected"
          }
          
          echo "✅ Deployment bundle validation completed"
      
      - name: Generate deployment manifest
        run: |
          echo "📄 Generating deployment manifest..."
          
          node -e "
            async function generateDeploymentManifest() {
              // Use dynamic imports for ES modules
              const fs = await import('fs');
              const path = await import('path');
              const { execSync } = await import('child_process');
              
              const packageJson = JSON.parse(fs.readFileSync('./server/package.json', 'utf8'));
              
              const manifest = {
                version: packageJson.version,
                buildDate: new Date().toISOString(),
                commit: execSync('git rev-parse HEAD').toString().trim(),
                branch: execSync('git branch --show-current').toString().trim(),
                nodeVersion: process.version,
                platform: process.platform,
                arch: process.arch,
                artifacts: {
                  bundle: 'deployment-bundle/',
                  sourceMap: 'Available in dist/*.map files',
                  size: execSync('du -sh deployment-bundle').toString().split('\t')[0]
                },
                dependencies: Object.keys(packageJson.dependencies || {}),
                scripts: {
                  start: 'npm start',
                  production: 'NODE_ENV=production npm start'
                },
                deployment: {
                  requirements: {
                    node: packageJson.engines?.node || '>=16',
                    npm: '>=6'
                  },
                  environment: {
                    NODE_ENV: 'production',
                    MCP_SERVER_ROOT: 'Optional - override server root detection',
                    MCP_PROMPTS_CONFIG_PATH: 'Optional - direct path to prompts config'
                  },
                  commands: {
                    install: 'npm install --only=production',
                    start: 'npm start',
                    health: 'curl -f http://localhost:3000/health || exit 1'
                  }
                }
              };
              
              fs.writeFileSync('deployment-manifest.json', JSON.stringify(manifest, null, 2));
              console.log('✅ Deployment manifest generated');
            }
            
            generateDeploymentManifest().catch(error => {
              console.error('❌ Deployment manifest generation failed:', error.message);
              process.exit(1);
            });
          "
      
      - name: Upload deployment artifacts
        uses: actions/upload-artifact@v4
        with:
          name: deployment-bundle-${{ github.sha }}
          path: |
            deployment-bundle/
            deployment-manifest.json
          retention-days: 90

  release-automation-preparation:
    name: Release Automation Preparation
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'
          cache-dependency-path: server/package-lock.json
      
      - name: Install dependencies
        run: |
          cd server
          npm ci --prefer-offline --no-audit
      
      - name: Generate changelog
        run: |
          echo "📝 Generating changelog..."
          
          # Get the latest tag
          latest_tag=$(git describe --tags --abbrev=0 2>/dev/null || echo "")
          
          if [ -z "$latest_tag" ]; then
            echo "📋 No previous tags found, generating initial changelog..."
            range="HEAD"
          else
            echo "📋 Generating changelog since $latest_tag..."
            range="$latest_tag..HEAD"
          fi
          
          # Generate changelog
          cat > CHANGELOG.md << 'EOF'
# Changelog

All notable changes to this project will be documented in this file.

The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/),
and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).

EOF
          
          # Add current version section
          current_version=$(node -e "console.log(require('./server/package.json').version)")
          echo "## [${current_version}] - $(date +%Y-%m-%d)" >> CHANGELOG.md
          echo "" >> CHANGELOG.md
          
          # Get commits since last tag
          echo "### Added" >> CHANGELOG.md
          git log $range --oneline --grep="feat:" --grep="add:" --grep="implement:" | sed 's/^/- /' >> CHANGELOG.md || true
          echo "" >> CHANGELOG.md
          
          echo "### Changed" >> CHANGELOG.md
          git log $range --oneline --grep="update:" --grep="modify:" --grep="change:" | sed 's/^/- /' >> CHANGELOG.md || true
          echo "" >> CHANGELOG.md
          
          echo "### Fixed" >> CHANGELOG.md
          git log $range --oneline --grep="fix:" --grep="resolve:" --grep="correct:" | sed 's/^/- /' >> CHANGELOG.md || true
          echo "" >> CHANGELOG.md
          
          echo "### Security" >> CHANGELOG.md
          git log $range --oneline --grep="security:" --grep="vulnerability:" | sed 's/^/- /' >> CHANGELOG.md || true
          echo "" >> CHANGELOG.md
          
          # Add all commits if no categorized commits found
          if [ $(git log $range --oneline | wc -l) -gt 0 ] && [ $(grep -c "^- " CHANGELOG.md) -eq 0 ]; then
            echo "### All Changes" >> CHANGELOG.md
            git log $range --oneline | sed 's/^/- /' >> CHANGELOG.md
            echo "" >> CHANGELOG.md
          fi
          
          echo "✅ Changelog generated"
      
      - name: Prepare version bump
        run: |
          echo "🔢 Preparing version bump..."
          
          cd server
          current_version=$(node -e "console.log(require('./package.json').version)")
          echo "Current version: $current_version"
          
          # Extract version parts
          major=$(echo $current_version | cut -d. -f1)
          minor=$(echo $current_version | cut -d. -f2)
          patch=$(echo $current_version | cut -d. -f3)
          
          # Calculate next versions
          next_patch="$major.$minor.$((patch + 1))"
          next_minor="$major.$((minor + 1)).0"
          next_major="$((major + 1)).0.0"
          
          echo "Next patch version: $next_patch"
          echo "Next minor version: $next_minor"
          echo "Next major version: $next_major"
          
          # Save version information
          cat > ../version-info.json << EOF
{
  "current": "$current_version",
  "next": {
    "patch": "$next_patch",
    "minor": "$next_minor",
    "major": "$next_major"
  }
}
EOF
          
          echo "✅ Version bump preparation completed"
      
      - name: Prepare release notes template
        run: |
          echo "📄 Preparing release notes template..."
          
          current_version=$(node -e "console.log(require('./server/package.json').version)")
          
          cat > RELEASE_NOTES.md << EOF
# Release Notes - v${current_version}

## 🚀 What's New

### Key Features
- [Add key features here]

### Enhancements
- [Add enhancements here]

### Bug Fixes
- [Add bug fixes here]

## 📊 Statistics

### Build Information
- Node.js version: $(node --version)
- Build date: $(date)
- Commit: $(git rev-parse HEAD)

### Package Information
- Total size: $(du -sh server/dist | cut -f1)
- Dependencies: $(node -e "console.log(Object.keys(require('./server/package.json').dependencies || {}).length)")

## 🧪 Testing

### Test Coverage
- Enhanced test suite with comprehensive validation
- Cross-platform compatibility testing
- Performance regression testing
- Security vulnerability scanning

### CI/CD Pipeline
- ✅ Core CI pipeline validation
- ✅ Enhanced quality gates
- ✅ Multi-environment testing
- ✅ Deployment preparation

## 📦 Installation

\`\`\`bash
npm install
npm run build
npm start
\`\`\`

## 🔧 Configuration

See [Configuration Guide](docs/configuration.md) for detailed setup instructions.

## 🐛 Known Issues

No known issues at this time.

## 📚 Documentation

- [API Documentation](docs/api.md)
- [Configuration Guide](docs/configuration.md)
- [Development Guide](docs/development.md)

## 🤝 Contributing

See [CONTRIBUTING.md](CONTRIBUTING.md) for contribution guidelines.

## 📄 License

This project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details.
EOF
          
          echo "✅ Release notes template prepared"
      
      - name: Generate semantic version tags
        run: |
          echo "🏷️  Generating semantic version tag information..."
          
          cd server
          current_version=$(node -e "console.log(require('./package.json').version)")
          
          # Check if version is semantic
          if [[ $current_version =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
            echo "✅ Current version follows semantic versioning: $current_version"
          else
            echo "⚠️  Current version does not follow semantic versioning: $current_version"
          fi
          
          # Generate tag information
          echo "📋 Tag information:"
          echo "  Current tag: v$current_version"
          echo "  Tag message: Release version $current_version"
          echo "  Tag command: git tag -a v$current_version -m \"Release version $current_version\""
          
          # Check for existing tags
          if git tag -l "v$current_version" | grep -q "v$current_version"; then
            echo "⚠️  Tag v$current_version already exists"
          else
            echo "✅ Tag v$current_version is available"
          fi
          
          echo "✅ Semantic version tag information generated"
      
      - name: Upload release preparation artifacts
        uses: actions/upload-artifact@v4
        with:
          name: release-preparation-${{ github.sha }}
          path: |
            CHANGELOG.md
            RELEASE_NOTES.md
            version-info.json
          retention-days: 30

  advanced-security-compliance:
    name: Advanced Security & Compliance Scanning
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'
          cache-dependency-path: server/package-lock.json
      
      - name: Install dependencies
        run: |
          cd server
          npm ci --prefer-offline --no-audit
      
      - name: Advanced dependency audit
        run: |
          cd server
          echo "🔍 Running advanced dependency audit..."
          
          # Create detailed audit report
          npm audit --audit-level=low --json > ../audit-detailed.json 2>/dev/null || true
          
          node -e "
            async function advancedDependencyAudit() {
              // Use dynamic imports for ES modules
              const fs = await import('fs');
              
              try {
                const auditData = JSON.parse(fs.readFileSync('../audit-detailed.json', 'utf8'));
                
                console.log('📊 Advanced Dependency Audit Report:');
                console.log('====================================');
                
                if (auditData.vulnerabilities) {
                  const vulns = auditData.vulnerabilities;
                  const packages = Object.keys(vulns);
                  
                  console.log('\\n🔍 Vulnerability Analysis:');
                  console.log('Total packages analyzed:', packages.length);
                  
                  // Group by severity
                  const severityGroups = {
                    critical: [],
                    high: [],
                    moderate: [],
                    low: [],
                    info: []
                  };
                  
                  packages.forEach(pkg => {
                    const vuln = vulns[pkg];
                    if (vuln.severity && severityGroups[vuln.severity]) {
                      severityGroups[vuln.severity].push({
                        name: pkg,
                        severity: vuln.severity,
                        via: vuln.via,
                        effects: vuln.effects
                      });
                    }
                  });
                  
                  Object.entries(severityGroups).forEach(([severity, vulnList]) => {
                    if (vulnList.length > 0) {
                      console.log('\\n' + severity.toUpperCase() + ' (' + vulnList.length + '):');
                      vulnList.forEach(vuln => {
                        console.log('  - ' + vuln.name + ' (via: ' + (vuln.via ? vuln.via.join(', ') : 'direct') + ')');
                      });
                    }
                  });
                  
                  // Generate recommendations
                  console.log('\\n💡 Recommendations:');
                  if (severityGroups.critical.length > 0) {
                    console.log('  🚨 CRITICAL: Immediate action required - update or replace vulnerable packages');
                  }
                  if (severityGroups.high.length > 0) {
                    console.log('  🔴 HIGH: Plan updates within 1-2 weeks');
                  }
                  if (severityGroups.moderate.length > 0) {
                    console.log('  🟡 MODERATE: Consider updates in next release cycle');
                  }
                  if (severityGroups.low.length > 0) {
                    console.log('  🟢 LOW: Monitor for future updates');
                  }
                  
                  // Exit with error for critical vulnerabilities
                  if (severityGroups.critical.length > 0) {
                    console.log('\\n❌ Build failed due to critical vulnerabilities');
                    process.exit(1);
                  }
                } else {
                  console.log('✅ No vulnerabilities found');
                }
              } catch (error) {
                console.log('⚠️  Could not parse audit results, continuing with basic check...');
              }
            }
            
            advancedDependencyAudit().catch(error => {
              console.error('❌ Advanced dependency audit failed:', error.message);
              // Don't exit with error as this is advisory
            });
          "
      
      - name: License compliance deep scan
        run: |
          cd server
          echo "🔍 Running license compliance deep scan..."
          
          node -e "
            async function licenseComplianceDeepScan() {
              // Use dynamic imports for ES modules
              const fs = await import('fs');
              const path = await import('path');
              
              console.log('📊 License Compliance Deep Scan:');
              console.log('================================');
              
              const packageJson = JSON.parse(fs.readFileSync('./package.json', 'utf8'));
              const licenseReport = {};
              const issues = [];
              
              // Analyze dependencies
              const dependencies = {
                ...packageJson.dependencies,
                ...packageJson.devDependencies
              };
              
              console.log('\\n🔍 Analyzing', Object.keys(dependencies).length, 'dependencies...');
              
              Object.keys(dependencies).forEach(depName => {
                try {
                  const depPackagePath = path.join('node_modules', depName, 'package.json');
                  if (fs.existsSync(depPackagePath)) {
                    const depPackage = JSON.parse(fs.readFileSync(depPackagePath, 'utf8'));
                    const license = depPackage.license || 'UNKNOWN';
                    
                    if (!licenseReport[license]) {
                      licenseReport[license] = [];
                    }
                    licenseReport[license].push(depName);
                    
                    // Check for problematic licenses
                    const problematicLicenses = ['GPL-2.0', 'GPL-3.0', 'AGPL-3.0', 'LGPL-2.1', 'LGPL-3.0'];
                    if (problematicLicenses.some(prob => license.includes(prob))) {
                      issues.push({
                        package: depName,
                        license: license,
                        severity: 'high',
                        reason: 'Copyleft license may require source code disclosure'
                      });
                    }
                    
                    // Check for unknown licenses
                    if (license === 'UNKNOWN' || !license) {
                      issues.push({
                        package: depName,
                        license: license,
                        severity: 'medium',
                        reason: 'License not specified or unknown'
                      });
                    }
                  }
                } catch (error) {
                  // Ignore packages that can't be analyzed
                }
              });
              
              console.log('\\n📋 License Distribution:');
              Object.entries(licenseReport)
                .sort(([,a], [,b]) => b.length - a.length)
                .forEach(([license, packages]) => {
                  console.log('  ' + license + ': ' + packages.length + ' package(s)');
                });
              
              if (issues.length > 0) {
                console.log('\\n⚠️  License Issues Found:');
                issues.forEach(issue => {
                  console.log('  ' + issue.severity.toUpperCase() + ': ' + issue.package + ' (' + issue.license + ')');
                  console.log('    ' + issue.reason);
                });
                
                const highIssues = issues.filter(i => i.severity === 'high');
                if (highIssues.length > 0) {
                  console.log('\\n🚨 High severity license issues require review before production deployment');
                }
              } else {
                console.log('\\n✅ No license compliance issues detected');
              }
            }
            
            licenseComplianceDeepScan().catch(error => {
              console.error('❌ License compliance scan failed:', error.message);
              // Don't exit with error as this is advisory
            });
          "
      
      - name: Security configuration audit
        run: |
          cd server
          echo "🔍 Running security configuration audit..."
          
          node -e "
            const fs = require('fs');
            const path = require('path');
            
            console.log('📊 Security Configuration Audit:');
            console.log('================================');
            
            const securityChecks = [];
            
            // Check package.json security settings
            const packageJson = require('./package.json');
            
            if (packageJson.private === true) {
              securityChecks.push({ check: 'Package privacy', status: 'PASS', message: 'Package marked as private' });
            } else {
              securityChecks.push({ check: 'Package privacy', status: 'WARN', message: 'Package not marked as private' });
            }
            
            // Check for engines specification
            if (packageJson.engines && packageJson.engines.node) {
              securityChecks.push({ check: 'Node.js version lock', status: 'PASS', message: 'Node.js version specified' });
            } else {
              securityChecks.push({ check: 'Node.js version lock', status: 'WARN', message: 'Node.js version not specified' });
            }
            
            // Check TypeScript configuration
            if (fs.existsSync('./tsconfig.json')) {
              const tsConfig = JSON.parse(fs.readFileSync('./tsconfig.json', 'utf8'));
              
              if (tsConfig.compilerOptions) {
                const securityOptions = {
                  strict: 'Strict type checking enabled',
                  noImplicitAny: 'No implicit any types',
                  strictNullChecks: 'Strict null checks',
                  noImplicitReturns: 'No implicit returns'
                };
                
                Object.entries(securityOptions).forEach(([option, description]) => {
                  if (tsConfig.compilerOptions[option]) {
                    securityChecks.push({ check: option, status: 'PASS', message: description });
                  } else {
                    securityChecks.push({ check: option, status: 'WARN', message: description + ' (disabled)' });
                  }
                });
              }
            }
            
            // Check for security-related dependencies
            const securityDeps = ['helmet', 'cors', 'express-rate-limit', 'express-validator'];
            securityDeps.forEach(dep => {
              if (packageJson.dependencies && packageJson.dependencies[dep]) {
                securityChecks.push({ check: dep, status: 'PASS', message: 'Security dependency present' });
              } else {
                securityChecks.push({ check: dep, status: 'INFO', message: 'Security dependency not found (may not be needed)' });
              }
            });
            
            // Check for .env files
            const envFiles = ['.env', '.env.local', '.env.production'];
            envFiles.forEach(file => {
              if (fs.existsSync(file)) {
                securityChecks.push({ check: file, status: 'WARN', message: 'Environment file found - ensure not committed' });
              }
            });
            
            // Display results
            console.log('\\n🔍 Security Configuration Results:');
            securityChecks.forEach(check => {
              const icon = {
                PASS: '✅',
                WARN: '⚠️',
                FAIL: '❌',
                INFO: 'ℹ️'
              }[check.status];
              
              console.log('  ' + icon + ' ' + check.check + ': ' + check.message);
            });
            
            const warnings = securityChecks.filter(c => c.status === 'WARN');
            const failures = securityChecks.filter(c => c.status === 'FAIL');
            
            console.log('\\n📊 Security Audit Summary:');
            console.log('  Passed: ' + securityChecks.filter(c => c.status === 'PASS').length);
            console.log('  Warnings: ' + warnings.length);
            console.log('  Failures: ' + failures.length);
            
            if (failures.length > 0) {
              console.log('\\n❌ Security audit failed - critical issues found');
              process.exit(1);
            } else if (warnings.length > 0) {
              console.log('\\n⚠️  Security audit passed with warnings - review recommended');
            } else {
              console.log('\\n✅ Security audit passed - no issues found');
            }
          "
      
      - name: Supply chain security validation
        run: |
          cd server
          echo "🔍 Running supply chain security validation..."
          
          node -e "
            async function supplyChainSecurityValidation() {
              // Use dynamic imports for ES modules
              const fs = await import('fs');
              const crypto = await import('crypto');
              
              console.log('📊 Supply Chain Security Validation:');
              console.log('===================================');
              
              // Check package-lock.json integrity
              if (fs.existsSync('package-lock.json')) {
                const packageLock = JSON.parse(fs.readFileSync('package-lock.json', 'utf8'));
                
                console.log('\\n🔒 Package Lock Analysis:');
                console.log('  Lock file version:', packageLock.lockfileVersion);
                console.log('  Dependencies with integrity hashes:', 
                  Object.values(packageLock.dependencies || {})
                    .filter(dep => dep.integrity)
                    .length
                );
                
                // Check for suspicious patterns
                const suspiciousPatterns = [
                  'postinstall',
                  'preinstall',
                  'install',
                  'eval',
                  'child_process',
                  'fs.writeFile'
                ];
                
                let suspiciousPackages = [];
                Object.entries(packageLock.dependencies || {}).forEach(([name, info]) => {
                  if (info.scripts) {
                    Object.entries(info.scripts).forEach(([script, command]) => {
                      if (suspiciousPatterns.some(pattern => command.includes(pattern))) {
                        suspiciousPackages.push({ name, script, command });
                      }
                    });
                  }
                });
                
                if (suspiciousPackages.length > 0) {
                  console.log('\\n⚠️  Suspicious package scripts detected:');
                  suspiciousPackages.forEach(pkg => {
                    console.log('  - ' + pkg.name + ' (' + pkg.script + '): ' + pkg.command.substring(0, 50) + '...');
                  });
                } else {
                  console.log('\\n✅ No suspicious package scripts detected');
                }
              }
              
              // Check for known malicious packages (basic check)
              const packageJson = JSON.parse(fs.readFileSync('./package.json', 'utf8'));
              const allDeps = {
                ...packageJson.dependencies,
                ...packageJson.devDependencies
              };
              
              const knownMaliciousPatterns = [
                'event-stream',
                'eslint-scope',
                'getcookies',
                'rc',
                'cross-env'
              ];
              
              const flaggedPackages = Object.keys(allDeps).filter(dep => 
                knownMaliciousPatterns.some(pattern => dep.includes(pattern))
              );
              
              if (flaggedPackages.length > 0) {
                console.log('\\n⚠️  Packages matching known malicious patterns:');
                flaggedPackages.forEach(pkg => {
                  console.log('  - ' + pkg + ' (version: ' + allDeps[pkg] + ')');
                });
                console.log('  Manual review recommended for these packages');
              } else {
                console.log('\\n✅ No packages match known malicious patterns');
              }
              
              console.log('\\n✅ Supply chain security validation completed');
            }
            
            supplyChainSecurityValidation().catch(error => {
              console.error('❌ Supply chain security validation failed:', error.message);
              // Don't exit with error as this is advisory
            });
          "
      
      - name: Generate security report
        run: |
          echo "📊 Generating comprehensive security report..."
          
          cat > security-report.md << 'EOF'
# Security Report

## 🔍 Audit Summary

### Dependency Vulnerabilities
- **Status**: See detailed audit above
- **Critical**: 0 (Build fails if >0)
- **High**: As reported
- **Moderate**: As reported
- **Low**: As reported

### License Compliance
- **Status**: Reviewed for copyleft licenses
- **Flagged**: Packages with GPL, AGPL, or LGPL licenses
- **Unknown**: Packages without license information

### Security Configuration
- **TypeScript**: Strict mode configuration
- **Dependencies**: Security-focused packages
- **Environment**: Production hardening

### Supply Chain Security
- **Package Lock**: Integrity hash validation
- **Scripts**: Suspicious script detection
- **Known Threats**: Pattern matching against known malicious packages

## 📋 Recommendations

### Immediate Actions
1. Review and update any critical vulnerabilities
2. Ensure license compliance for production use
3. Validate security configuration settings

### Ongoing Monitoring
1. Regular dependency updates
2. Security advisory monitoring
3. Supply chain threat intelligence

### Best Practices
1. Use npm audit regularly
2. Keep dependencies up to date
3. Monitor security advisories
4. Implement security scanning in CI/CD

## 🔧 Tools Used

- npm audit (dependency vulnerabilities)
- Custom license scanner
- TypeScript configuration analysis
- Supply chain security validation

## 📅 Generated

- Date: $(date)
- Commit: $(git rev-parse HEAD)
- Branch: $(git branch --show-current)
EOF
          
          echo "✅ Security report generated"
      
      - name: Upload security compliance artifacts
        uses: actions/upload-artifact@v4
        with:
          name: security-compliance-${{ github.sha }}
          path: |
            audit-detailed.json
            security-report.md
          retention-days: 90
      
      - name: Deployment preparation summary
        run: |
          echo "🎉 Deployment Preparation Summary"
          echo "================================="
          echo ""
          echo "✅ Completed Tasks:"
          echo "  🔨 Artifact generation with production build"
          echo "  🗺️  Source maps for debugging"
          echo "  📦 Deployment bundle creation"
          echo "  📄 Deployment manifest generation"
          echo "  📝 Changelog and release notes preparation"
          echo "  🔢 Version bump preparation"
          echo "  🏷️  Semantic versioning tag information"
          echo "  🔍 Advanced security and compliance scanning"
          echo "  📊 Comprehensive security reporting"
          echo ""
          echo "📦 Artifacts Generated:"
          echo "  - deployment-bundle/ (production-ready package)"
          echo "  - deployment-manifest.json (deployment instructions)"
          echo "  - CHANGELOG.md (version history)"
          echo "  - RELEASE_NOTES.md (release documentation)"
          echo "  - version-info.json (semantic versioning)"
          echo "  - security-report.md (security compliance)"
          echo ""
          echo "🚀 Ready for Production Deployment!"
          echo "Next steps: Review artifacts and proceed with deployment"